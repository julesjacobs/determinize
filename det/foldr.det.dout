== Elaboration ==
raw:
( let foldr =
    ( fun f =>
          ( fun z =>
                ( rec go xs =>
                      ( match ( xs : [ float[?m2] ] ) with
                            | [] => ( z : float[?m2] )
                            | x :: xs => ( ( f : float[?m2] ->  float[?m2] ->  float[?m2] ) ( ( ( go : [ float[?m2] ] ->  float[?m2] ) ( xs
                                            : [ float[?m2] ] ) : float[?m2] ) ) ( x : float[?m2] ) : float[?m2] ) : float[?m2] ) : [
                        float[?m2] ] ->  float[?m2] ) : float[?m2] ->  [ float[?m2] ] ->  float[?m2] ) : float[?m2] ->  float[?m2] -> 
              float[?m2] ->  float[?m2] ->  [ float[?m2] ] ->  float[?m2] )
    in
    ( let sum =
          ( fun xs =>
                ( ( foldr : float[?m2] ->  float[?m2] ->  float[?m2] ->  float[?m2] ->  [ float[?m2] ] ->  float[?m2] ) ( xs : [ float[?m2]
                          ] ) ( 0 : float[?m3] ) ( ( fun x =>
                            ( fun acc => ( ( x : float[?m2] ) + ( acc : float[?m2] ) : float[?m2] ) : float[?m2] ->  float[?m2] ) :
                            float[?m2] ->  float[?m2] ->  float[?m2] ) ) : float[?m2] ) : [ float[?m2] ] ->  float[?m2] )
          in
          ( let samples =
                ( ( uniform( ( 0 : float[?m4] ), ( 1 : float[?m4] ) ) : float[?m4] ) :: ( ( gauss( ( 1 : float[?m5] ), ( 0.2 : float[G] ) )
                                  : float[?m5] ) :: ( ( 2.5 : float[?m7] ) :: ( ( gauss( ( 0.5 : float[?m8] ), ( 0.05 : float[G] ) ) :
                                              float[?m8] ) :: ( [] : [ float[?m8] ] ) : [ float[?m8] ] ) : [ float[?m7] ] ) : [ float[?m5] ]
                        ) : [ float[?m4] ] )
                in
                ( ( sum : [ float[?m2] ] ->  float[?m2] ) ( samples : [ float[?m2] ] ) : float[?m2] ) : float[?m2] ) : float[?m2] ) :
    float[?m2] )
defaulted:
( let foldr =
    ( fun f =>
          ( fun z =>
                ( rec go xs =>
                      ( match ( xs : [ float[E] ] ) with
                            | [] => ( z : float[E] )
                            | x :: xs => ( ( f : float[E] ->  float[E] ->  float[E] ) ( ( ( go : [ float[E] ] ->  float[E] ) ( xs : [
                                              float[E] ] ) : float[E] ) ) ( x : float[E] ) : float[E] ) : float[E] ) : [ float[E] ] -> 
                        float[E] ) : float[E] ->  [ float[E] ] ->  float[E] ) : float[E] ->  float[E] ->  float[E] ->  float[E] ->  [
                float[E] ] ->  float[E] )
    in
    ( let sum =
          ( fun xs =>
                ( ( foldr : float[E] ->  float[E] ->  float[E] ->  float[E] ->  [ float[E] ] ->  float[E] ) ( xs : [ float[E] ] ) ( 0 :
                          float[E] ) ( ( fun x =>
                            ( fun acc => ( ( x : float[E] ) + ( acc : float[E] ) : float[E] ) : float[E] ->  float[E] ) : float[E] -> 
                              float[E] ->  float[E] ) ) : float[E] ) : [ float[E] ] ->  float[E] )
          in
          ( let samples =
                ( ( uniform( ( 0 : float[E] ), ( 1 : float[E] ) ) : float[E] ) :: ( ( gauss( ( 1 : float[E] ), ( 0.2 : float[G] ) ) :
                                  float[E] ) :: ( ( 2.5 : float[E] ) :: ( ( gauss( ( 0.5 : float[E] ), ( 0.05 : float[G] ) ) : float[E] ) ::
                                          ( [] : [ float[E] ] ) : [ float[E] ] ) : [ float[E] ] ) : [ float[E] ] ) : [ float[E] ] )
                in
                ( ( sum : [ float[E] ] ->  float[E] ) ( samples : [ float[E] ] ) : float[E] ) : float[E] ) : float[E] ) : float[E] )

== Determinized ==
let foldr =
fun f => fun z => rec go xs => match xs with | [] => z | x :: xs => f ( go xs ) x
in
let sum = fun xs => foldr xs 0 ( fun x => fun acc => x + acc ) in let samples = ( 0 + 1 ) * 0.5 :: 1 :: 2.5 :: 0.5 :: [] in sum samples

== Evaluation (100 trials) ==
program mean: 4.46939
determinized mean: 4.5
